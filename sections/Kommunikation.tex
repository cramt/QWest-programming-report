\chapter{Kommunikation}\label{ch:communication}
% How does the communication work (between services, and between each element in the system)
% Architecture structure 
% "What happens in between architectural components?"
% Client -> WCF (WSDL, SOAP, Proxies, HTTP, TCP, etc.)
% DbLayer -> Database (Connections, SQL, deserializing data, etc.)

\section{Sikkerhed}\label{sec:security}
% Security
% Identify security problems in the application, and figure out solutions. Explain identified problems, and possible solutions. 
% Keywords: SSL/TLS, Hashing, Salting, XSS, SQL Injection, CSRF, Overposting(for MVC), Man in the middle attacks, DDOS, Authentication
HTTPS vil være den primærer måde at sikre os at bruger input er sikkert enkrypteret mens de bliver transporeret til QWest.Api, .NET framework skulle have support for HTTPS. \cite{DotNetFrameworkSSL} dog har der ikke været arbejde til at sætte dette op eftersom at vi ikke ejer it SSL certificate.

For at sikre vores brugerer mod leaking af deres passwords hvis et data breach sker hasher og salter vi alle brugeres passwords \texttt{Rfc2898DeriveBytes} \cite{Rfc2898DeriveBytes} til dette, denne klasse bruger SHA1 en utrolig ikke sikker hashing metode som vi burde ændre snarest muligt \cite{HowsecureisSHA1} til BCrypt \cite{BCrypt} eller lignende.

\section{Transactions}\label{sec:transactions}
% Transactions
% Identify places in the application where we need transactions
% How do we build our transactions? Isolation levels?
% Do we need distributed transactions?
% ACID, Parallelism, Async/Await,
% Implementation details welcome

\section{Protokoller}\label{sec:protocols}
Kommunikationen mellem alle services'ne i QWest er http requests, med untagelse af kommunikationen med databasen fra QWest.DataAccess. kommunikationen fra vores frontend web klient til QWest.Api (endten direkte eller proxiet gennem QWest.Web) skal selfølgelig være http eftersom at der ikke er webstandarder for andre muligheder, den eneste untagelse værende WebSockets, dog er dette ikke usecasen for WebSockets og WebSockets har ikke lige så stor support blandt ældrere browsere som en help normal http request har. Denne kommunikationen bruger igen JSON eftersom at frontend browser javascript ikke supporter mange andre måder at serializere og deserializere data på

Der kan argumenteres for brug af en anden type kommunikationen til og fra QWest.Email eftersom at node.js har muligheden for rå TCP og UDP, og en serializerings metode some protobuf \cite{ProtoBuf} eller binary serializering \cite{CsharpBinarySerialization} ville dette unødvendig kompleksitet ind i projektet og introdusere tredjepartsbiblioteker i enten QWest.Email eller andre services som bruger QWest.Email, derfor ender QWest.Email med at følge standarden sat af QWest.Api og bruge standard http requests der sender JSON serializeret data.

\section{Caching and HTTP optimization}\label{sec:caching}
