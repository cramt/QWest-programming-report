% Implementation
% Remember code snippets
% Services
% Authentication
% Transactions
% Testing
%%% what testing framework(s) did we use and why?
%%% Reasoning over these 
%%% Choice and reason for choice
%%% Results from testing
% Exception handling
% Performance
\chapter{Implementation}\label{ch:implementation}

\section{Database og persistence}\label{sec:database}

\subsection{SQL og DAO}\label{sec:sqlOgDao}
Eftersom bruger at vi bruger ADO.NET direkte uden nogen form for ORM eller lignende, betyder det at vi skal skrive vores egen SQL og DAO metoder, måden dette er implementeret på er DAO interfaces og statiske properties som vær returnerer den tilsvarende interface, disse interfaces der beskriver de metoder vi forventer en specific DAO metode at have og ligesom andre c\# interfaces er dette uafhængigt af den faktuelle logik der implementeret.
Denne metode har 2 primærer fordelle, vi kan næmt lave mocking klasser af vores DAO klasser some andre klasser vil accepter som DAO klasser i et unit testing miljø, et eksempel på dette kan sees i \texttt{ImageControllerSpec} \ref{lst:imageControllerSpec}.
Den sekundærer fordel er utrolig lav kobling mellem logikken i vores DAO metoder og resten af koden, dette kan være en kæmpe fordel hvis at Microsoft SQL et tidspunkt i fremtiden blev deprecated, og vi skal skifte database til mysql fx ville det ikke være svært at implementere dette eftersom at alt kode der kalder DAO metoder kalder dem gennem interfaces, dette vil sige at alle ændrer i koden vil kun ske i QWest.DataAccess, et eksempel på en DAO interface med tilsvarende property kan findes i \texttt{QWest.DataAccess.DAO.IProgressMap} \ref{lst:progressMapDaoInterface}.
lige nu bruger koden en Microsoft SQL database så derfor er property'en defaulted til Mssql implementationen af interfacen

\begin{listing}[p]
    \begin{minted}
    [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=LightGray,
        fontsize=\footnotesize,
        linenos,
        breaklines
    ]{csharp}
namespace QWest.Api.Tests {
    [TestFixture]
    public class ImageControllerSpec {
        public class ImageRepoMock : DAO.IImage {
            public Dictionary<int, byte[]> ImageDictionary { get; set; }
            public Task<byte[]> Get(int id) {
                return Task.FromResult(ImageDictionary[id]);
            }
        }
        [Test]
        public async Task NullReturnsValidImage() {
            ImageController imageController = new ImageController();
            imageController.ImageRepo = new ImageRepoMock();
            byte[] bytes = await (await imageController.Get(null)).Content.ReadAsByteArrayAsync();
            Assert.IsNotEmpty(bytes);
        }
        [Test]
        public async Task ReturnsCorrectImage() {
            byte[] expected = new byte[] { 1, 2, 3 };
            ImageController imageController = new ImageController();
            imageController.ImageRepo = new ImageRepoMock {
                ImageDictionary = new Dictionary<int, byte[]> {
                    {5, expected }
                }
            };
            byte[] bytes = await (await imageController.Get(5)).Content.ReadAsByteArrayAsync();
            Assert.AreEqual(expected, bytes);
        }
    }
}
\end{minted}
    \caption{QWest.Api.Tests.ImageControllerSpec\label{lst:imageControllerSpec}}
\end{listing}

\begin{listing}[p]
    \begin{minted}
    [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=LightGray,
        fontsize=\footnotesize,
        linenos,
        breaklines
    ]{csharp}
namespace QWest.DataAccess {
    public static partial class DAO {
        public interface IProgressMap {
            Task<ProgressMap> Get(User user);
            Task<ProgressMap> Get(ProgressMap map);
            Task<ProgressMap> Get(int id);
            Task<ProgressMap> GetByUserId(int userId);
            Task Update(int id, List<int> additions, List<int> subtractions);
            Task Update(ProgressMap map);
        }
        public static IProgressMap ProgressMap { get; set; } = new Mssql.ProgressMapImpl(ConnectionWrapper.Instance);
    }
}
\end{minted}
    \caption{ProgressMap DAO interface\label{lst:progressMapDaoInterface}}
\end{listing}

\subsubsection{DbRep pattern}\label{sec:dbRep}
DbRep, en forkortelse for Database Representation, er en pattern vi har "opfundet" og bruger i mange af vores DAO metoder, DbRep er en god pattern til at stoppe kode duplikation når det kommer til \texttt{select} DAO metoder.
Alt i alt består denne pattern af at lave en klasse som reflekterer resultated af en select metode, DbRep klassens constructor tager imod en individuel row, i c\# vi dette være i form a en \texttt{SqlDataReader}, og udpakker vært row til en property in denne klasse, klassen skal representere select resultated og constructoren skal udpakke resultated til properties i denne klasse.
Ind til videre hjælper denne klasse med ikke at duplikere koden for udpakningen af sql resultater, men vi kan også lave en metode på klassen, ofte kaldet \texttt{ToModel} som returnerer den model klasse some vores DAO interface kræver at vi returnerer.
Denne pattern kan gøre DAO metode skrivning nemerer eftersom udpakningen og konstruktionen af den model klassen der skal returneres allerede eksistere og vær DAO metode kan fokuseser på SQL'en.
En anden god fordel er at den splitter udpakning af data og mutering af data i two forskellige metoder, dette er vigtigt eftersom at vi gerne vil bruge så lidt tid so muligt med sql forbindelsen åben og det er kun udpakningen af data der kræver dette.
Et eksempel på en DbRep er PostDbRep \ref{lst:postDbRep}, constructoren's job er at udpakke værdierne og den gør intet andet, eftersom der er en sql forbindelse åben, data mutationen sker i ToModel, hvor vi først skal finde ud af om denne Post var lavet af en User eller en Group, der er komma seperarede strenge og json der skal parses, alt sammen ting som ikke burde gøres mens der er en utrolig dyr sql forbindelse åben.

\begin{listing}[p]
    \begin{minted}
    [
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        bgcolor=LightGray,
        fontsize=\footnotesize,
        linenos,
        breaklines
    ]{csharp}
[Serializable]
internal class PostDbRep : IDbRep<Post> {
    //deleted properties for readability in this snippet
    public PostDbRep(SqlDataReader reader) {
        int i = 0;
        Id = reader.GetSqlInt32(i++).Value;
        Content = reader.GetSqlString(i++).Value;
        UserId = reader.GetSqlInt32(i++).NullableValue();
        GroupId = reader.GetSqlInt32(i++).NullableValue();
        PostTime = reader.GetSqlInt32(i++).Value;
        Location = reader.GetSqlString(i++).NullableValue();
        Username = reader.GetSqlString(i++).NullableValue();
        PasswordHash = reader.GetSqlBinary(i++).NullableValue();
        Email = reader.GetSqlString(i++).NullableValue();
        UserDescription = reader.GetSqlString(i++).NullableValue();
        SessionCookie = reader.GetSqlBinary(i++).NullableValue();
        ProfilePicture = reader.GetSqlInt32(i++).NullableValue();
        Name = reader.GetSqlString(i++).NullableValue();
        CreationTime = reader.GetSqlInt32(i++).NullableValue();
        GroupDescription = reader.GetSqlString(i++).NullableValue();
        Images = reader.GetSqlString(i++).NullableValue();
        Members = reader.GetSqlString(i++).NullableValue();
    }

    public Post ToModel() {
        User userAuthor = null;
        Group groupAuthor = null;
        if (UserId != null) {
            userAuthor = new User(Username, PasswordHash, Email, UserDescription, SessionCookie, UserId) {
                ProfilePicture = ProfilePicture
            };
        }
        else if (GroupId != null) {
            groupAuthor = new Group(Name, (int)CreationTime, GroupDescription, null, Members.MapValue(UserDbRep.FromJson).Select(x => x.ToModel()), GroupId);
        }
        else {
            throw new ArgumentException("in this post the author is neither a user or group");
        }
        return new Post(Content, userAuthor, groupAuthor, PostTime, Images.MapValue(x => x.Split(',').Select(y => int.Parse(y)).ToList()), Location.MapValue(x => GeopoliticalLocationDbRep.ToTreeStructureFirst(GeopoliticalLocationDbRep.FromJson(x))), Id);
    }
}
\end{minted}
    \caption{PostDbRep\label{lst:postDbRep}}
\end{listing}

\subsection{Migration og backups}\label{sec:migration}
QWest bruger database migration pattern'en til database ændringer.
Database migration betyder at i stedet for at have et færdiggjord og definitivt sql script til at sætte databasen op, så er der mange sql scripts, i specifik ræggefølge, dette har en massiv fordel et enkelt, færdiggjord og definitivt sql script, der kan tilføjes ændringer til databasen tables uden at slette at data'en i databasen.

Dette er utrolig vigtigt for den agile udviklings metode, hvilket kræver et development-feedback loop mellem udvilkere og brugerer og for at dette kan være en realitet kræver det at applikationen der har persistence mellem updateringer for ikke at være forfærdelig for brugerne at bruge.

For ikke eksekvere en migration som allerede er i databasen har vi et extra table kaldet \texttt{info} med row'et \texttt{schema\_version} som holder styr på hvad nummeret på den sidste migration der blev eksekveret var.

QWest's migrationer kan alle sammen findes i QWest.DataAcess/Migrations, og er navngivet efter ræggefølge de skal eksekveres i, starter ved \texttt{1.sql} of på nuværende skrivnings tidspunkt ender ved \texttt{20.sql}

Efter migrationen processen i QWest insertet også backup geopolitisk data hvis intet geopolitisk data kan findes i databasen, dette er tildels af testing årsager eftersom at vores integration tests kunne finde på at slætte alle table's i databasen hvilket ville slette dette næsten statiske data, og tildels pga. af at dette skulle uploades til databasen første gang på en eller anden måde.

\section{Services}\label{sec:servicesImp}
QWest er en applikation bestående af services, endten skrevet i node.js eller c\#.

\section{Web design}\label{sec:webdesign}
\subsection{Back-end and logic}\label{sec:backend}
\subsection{Front-end and usability}\label{sec:frontend}


\section{Testing}\label{sec:testing}

\section{Webscraping af geopolitisk data}\label{sec:datascraping}
det geopolitiske data QWest projected omhandler sig om er bedst beskrevet af ISO 3166 standarden \cite{ISO3166}, primært ISO 3166-1 og ISO 3166-2, der er dog et stort problem ved dette data, ISO 3166-1 er perfect for vores use-case men ISO 3166-2 har problemmet med at alle navne på lande subdivisions are lokalle navne i det lokalle sprog, dette virker utrolig dårligt i QWest's situation eftersom at de rejsende ikke nødvendighvis ved hvad de lokalle navn for deres lokation er, og kun kender det engelske navn, det ville være en forfærdelig bruger oplevelse for fx en amerikans rejsende som to på ud og rejse i Nordjylland, men når han bruger vores applikation kan han ikke finde "Northern Denmark Region" hvilket er hvad denne region hedder for ham.

Løsningen på dette problem er selfølgelig at have en måde at have så mange mulige navne på alle steder så muligt, vigtigts værende det engelske/internationalle navn. Det eneste sted dette data kun blive fundet i en nogenlunde konsistent, nogenlunde computerlæselig måde er på wikipedia.

Wikimedia (platformen Wikipedia er bygget på) udbyder deres egen REST API \cite{Wikimedia-REST-API-Documentation}, ud over dette har Wikipedia en entry for vært lands ISO 3166-2, det vil sige all deres subdivisions, og de er alle navngivet \texttt{ISO\_3166-2:}<landets alpha2>, alle af disse sider er også opbygget på den samme måde, en tabel der med id'et til mest venstre og alt til højre fra dette er forskellige måder at skrive subdivision'ens navn på. Det eneste problem med dette data er at Wikimedia's REST API kan kun representere det i HTML form sammen med resten af den standard wikipedia side.

Alt i alt skal et program skrives som kan læse resultatet fra Wikimedia's REST API og derefter parse html'en og indsamle det data der er relevant. 
Denne slags program er ofte kaldet en \texttt{web scraper}, og QWest's Wikipedia web scraper kan findes i QWest koden i folderen \texttt{iso3166converter}.

\texttt{iso3166converter} er skrevet i ruby \cite{RubyLang}, et dynamisk programmerings sprog med fokusområde på at udviklingsværktøjer og hurtige scripts, meget ligesom python. \texttt{iso3166converter} bruger 2 gems (ruby's navn for tredjepartsbiblioteker) \texttt{nokogiri} \cite{nokogiri}, som bruges til at parse html, og \texttt{httparty} \cite{httparty}, som bruges til at sende http requests.

Ruby programmet får systematisk igennem vært land i ISO 3166-1 og finder deres subdivisions baseret på Wikipedia data og inserter det. Programmet gør få andre thing som fx at omnavngive mange af json navnene så de ikke indeholder et \texttt{"-"}. Når ruby programmet er færdigt laver den en JSON fil som er den original backup fil insættet i databasen, som er beskrevet i \ref{sec:migration}